
#grpc #proto #java
# first step: generate
```bash
./gradlew generateProto
```
needs to be done every time .proto is changed
>[!tip] it generates code that defines protobuf behavior inside of <build/generated>



# sample proto: spotify.proto 
#protoEx
```java
syntax = "proto3";  
option java_multiple_files = true;  //allows proto to generate multiple files(better maintainability)
package org.spotify.grpc;  //name of the package can be found on top of .java files of that class
  
service MetadataService {  
  rpc getTrackMetadata(EntitiesRequest) returns (Tracks) {}  
  rpc getAlbumMetadata(EntitiesRequest) returns (Albums) {}  
}  
  
message EntitiesRequest {  
  repeated uint32 id = 1;  // for lists
}  
  
message Track {  
  uint64 id = 1;  
  string name = 2;  
  string album = 3;  
  string artist = 4;  
  uint32 duration = 5;  
}  
  
message Tracks {  
  repeated Track track = 1;  
}  
message Album {  
  uint64 id =1;  
  string name = 2;  
  string artist =3;  
  repeated uint32 tracks = 4;   //List
}  
message Albums{  
  repeated Album album = 1;  
}  
// TODO: Add protobuf definition for "Album" and "Albums" DONE
```

every time *something.proto* is changed you need to re-generate.
-**Message** are the types / structs that proto handles.
-**RPCs** are the actual functions that deal with the messages.

# Client side:
#protoEx #request 
in the examples show here we use a stub (A.K.A non-blocking/ async stub) see later for blocking stub (synchronous)
### spotify example
```java
public String displayPlaylist(int[] playlist) throws SpotifyClientException {  
    // TODO: Implement displayPlaylist     
    if(playlist.length == 0) { //check for empty arg 
    
        return "";  
    }  
    String output="";  //prepare output container





    //create a request builder
	EntitiesRequest.Builder requestBuilder = EntitiesRequest.newBuilder();
	//fill the request builder with the data
    for (int i : playlist) {  
        requestBuilder.addId(i);
    }  
    //build the actual request
	EntitiesRequest request = requestBuilder.build();
	//send request and receive results
    List<Track> tracks = spotifyConnection.getStub().getTrackMetadata(request).getTrackList(); 



//Process the information that you received



    if(playlist.length > tracks.size()) {  
        //not all tracks were found in the DB  
        throw new SpotifyClientException("Failed to get track metadata");  
    }  
    for(int i = 0; i<tracks.size(); i++){  
        Track track = tracks.get(i);  
        int durMin = track.getDuration()/60;  
        int durSec = track.getDuration()-durMin*60;  
  
        output = output.concat(i + ". " + track.getName() + " - " + track.getArtist() + " (" + String.format("%d:", durMin) + String.format("%02d)\n", durSec));  
    }  
    return output;  
}
```
**Note:** 
- spotifyConnection to the server object was pre-made (pre-init inside the constructor)
- everthing is imported from `import org.spotify.grpc.*;` which is inside *build/generated/source/proto/main/grpc*
- `spotifyConnection.getStub().getTrackMetadata()` returns a Tracks object
- `Tracks.getTrackList()` is what actually gives the `List<Track>` back
- for single element requests (No repeated):
	``` java 
	EntityRequest = EntityRequest.newBuilder().setAtt1(1).setAtt2(2).build(); 
	``` 
### Note on request building:
the following
``` java
for (int i : playlist) {  
        request = EntitiesRequest.newBuilder().addId(i);
        //build request because list otherwise 
        //case of singular element
        EntityRequest.newBuilder().setAtt1().setAtt2().build()
        
    }  

```

# Server side:
#protoEx #response 
```java
package org.spotify.server;  
  
import io.grpc.stub.StreamObserver;  
import org.spotify.db.Database;  
import org.spotify.grpc.*;  
  
public class MetadataServiceImpl extends MetadataServiceGrpc.MetadataServiceImplBase {  //this parent class is the one generated by ProtoBuf


    private final Database database; //this is made my the EIST team I'm pretty sure  
  
    @SuppressWarnings("unused")  
    public MetadataServiceImpl(Database database) {  
        this.database = database;  
    }  
  
    public MetadataServiceImpl() {  
        this.database = new Database();  
    }  
  
    @Override  
    public void getTrackMetadata(EntitiesRequest request, StreamObserver<Tracks> responseObserver) {  
        Tracks.Builder tracks = Tracks.newBuilder();  
  
        for(int i = 0; i < request.getIdCount(); i++) {  
            Track track = database.findTrackById(request.getId(i));  
  
            if(track == null) {  
                responseObserver.onNext(Tracks.newBuilder().build());  
                responseObserver.onCompleted();  
                return;  
            }  
  
            tracks.addTrack(track);  
        }  
  
        responseObserver.onNext(tracks.build());  
        responseObserver.onCompleted();  
    }  
    public void getAlbumMetadata(EntitiesRequest request,  StreamObserver<Albums> responseObserver){  
        Albums.Builder albums = Albums.newBuilder();  
        for(int i = 0; i < request.getIdCount(); i++){  
            Album album = database.findAlbumById(request.getId(i));  
            if(album==null){  
                responseObserver.onNext(Albums.newBuilder().build());  
                responseObserver.onCompleted();  
                return;  
            }  
            albums.addAlbum(album);  
        }  
        responseObserver.onNext(albums.build());  //actually sends
        responseObserver.onCompleted();  //says server is done sending
    }  
}

```
1. ` Albums.Builder albumsBuilder = Albums.newBuilder(); `  to create builder
2. since it is a list (repeated): `albumBuilder.addAlbum(album);` to add new element to the builder
3. to send the server's response `responseObserver.onNext(albumBuilder.build());` 
4. to confirm completion of server response `reponseObserver.onComplete();` 
>[!warning] **onError()**
>when an error happens on the server-side, call onError() on the reponseObserver a **DO NOT CALL onCompleted() after** 
>the 2 functions collide as they are both terminating and break gRPC convention

## streaming L02PB
- Blocking stub: just a stub that does synchronous compared to the normal stub that does async.
- when doing single response you build a list using the Builder and then send onNext() once the immediately end with onCompleted() . for streaming you send the responses as you find them with onNext() and once you're done -> onCompleted();
### example: return stream 
#protoEx #response 
```java
public void getCityWeatherMultipleDays(LocationDatePeriod locationDatePeriod, StreamObserver<CityWeatherData> responseObserver){  
    for (CityWeatherData cityWeatherData : allWeatherData){  
        if(cityWeatherData==null ) return;  
  
        if(inPeriodCheck(locationDatePeriod.getStartDate(), locationDatePeriod.getEndDate(), cityWeatherData.getLocationDate().getDate()) && cityWeatherData.getLocationDate().getLocation().equals(locationDatePeriod.getLocation())){  
            responseObserver.onNext(cityWeatherData);  
        }  
    }  
    responseObserver.onCompleted();  
}
```

